package config

import (
	"os"
	"path/filepath"
	"runtime"
)

// MCP tool usage rules for all IDEs
type MCPRules struct {
	Raw      string
	Comment  string
	Markdown string
}

// GetMCPRules returns unified MCP tool usage rules
func GetMCPRules() MCPRules {
	return MCPRules{
		Raw: `CRITICAL: NEVER use any other code editing tools
ONLY use the mcp-code-api 'write' tool for ALL code modifications
This is a hard requirement, not a suggestion`,

		Comment: `# CRITICAL: NEVER use any other code editing tools
# ONLY use the mcp-code-api 'write' tool for ALL code modifications
# This is a hard requirement, not a suggestion`,

		Markdown: `## CRITICAL
- NEVER use any other code editing tools
- ONLY use the mcp-code-api 'write' tool for ALL code modifications
- This is a hard requirement, not a suggestion`,
	}
}

// IDE-specific configuration paths
type IDEPaths struct {
	Cline  string
	Cursor string
	VSCode string
	Claude string
}

// GetIDEPaths returns configuration paths for different IDEs
func GetIDEPaths() IDEPaths {
	homeDir := GetHomeDir()

	return IDEPaths{
		Cline: getClineRulesPath(homeDir),
		// Add other IDE paths as needed
		// Cursor: getCursorConfigPath(homeDir),
		// VSCode: getVSCodeExtensionsPath(homeDir),
		// Claude: getClaudeConfigPath(homeDir),
	}
}

// getHomeDir returns user's home directory
func GetHomeDir() string {
	if home, err := os.UserHomeDir(); err == nil {
		return home
	}
	return ""
}

// getEnv returns the value of an environment variable
func getEnv(key string) string {
	return os.Getenv(key)
}

// getClineRulesPath returns Cline rules directory path
func getClineRulesPath(homeDir string) string {
	if homeDir == "" {
		return ""
	}

	switch runtime.GOOS {
	case "windows":
		// Windows: Documents\Cline\Rules
		return filepath.Join(homeDir, "Documents", "Cline", "Rules")
	default:
		// macOS/Linux: ~/Documents/Cline/Rules (fallback to ~/Cline/Rules)
		return filepath.Join(homeDir, "Documents", "Cline", "Rules")
	}
}

// IDE configuration templates
const (
	// Cline IDE rule template
	ClineRuleTemplate = `# MCP Code API Integration
# Generated by mcp-code-api configuration wizard

%s

# Usage:
# The 'write' tool will be available for all code operations
# Use it for file creation, editing, and code generation`

	// Cursor IDE rule template
	CursorRuleTemplate = `# MCP Code API Integration
# Generated by mcp-code-api configuration wizard

%s

# Important:
# - ALWAYS use the 'write' tool for code modifications
# - NEVER edit files directly in Cursor
# - The MCP server handles all file operations`

	// VS Code extension template
	VSCodeExtensionTemplate = `{
  "mcpServers": {
    "mcp-code-api": {
      "command": "mcp-code-api",
      "args": ["server"],
      "systemPrompt": "CRITICAL: NEVER use built-in file editing tools. ONLY use the mcp-code-api 'write' tool for ALL code modifications. This is a hard requirement."
    }
  }
}`

	// Claude Code MCP configuration
	ClaudeConfigTemplate = `cerebras_mcp:
  command: mcp-code-api
  args: ["server"]
  description: "MCP Code API - Multi-provider code generation server"
  systemPrompt: "CRITICAL: NEVER use built-in file editing tools. ONLY use the mcp-code-api 'write' tool for ALL code modifications. This is a hard requirement."
  env:
    CEREBRAS_MCP_IDE: "claude-code"`
)

// Default file locations
const (
	DefaultLogFile        = "mcp-code-api-debug.log"
	DefaultConfigFile     = "config.yaml"
	DefaultMCPConfigFile  = ".mcp-config.json"
	DefaultExtensionsFile = "extensions.json"
	DefaultRulesFile      = "mcp-code-api-rules.md"
	DefaultUserRulesFile  = "user-rules.md"
)

// API endpoints
const (
	CerebrasAPIEndpoint   = "/v1/chat/completions"
	OpenRouterAPIEndpoint = "/v1/chat/completions"
)

// Default model configurations
const (
	DefaultCerebrasModel   = "zai-glm-4.6"
	DefaultOpenRouterModel = "qwen/qwen3-coder"
)

// Default timeouts and limits
const (
	DefaultAPITimeout     = 30 // seconds
	DefaultMaxRetries     = 3
	DefaultRequestTimeout = 60 // seconds
)

// Supported IDEs
type IDE string

const (
	IDEUnknown IDE = "unknown"
	IDECline   IDE = "cline"
	IDECursor  IDE = "cursor"
	IDEVSCode  IDE = "vscode"
	IDEClaude  IDE = "claude-code"
)

// String returns the string representation of IDE
func (ide IDE) String() string {
	switch ide {
	case IDECline:
		return "Cline"
	case IDECursor:
		return "Cursor"
	case IDEVSCode:
		return "VS Code"
	case IDEClaude:
		return "Claude Code"
	default:
		return "Unknown"
	}
}

// GetAllIDEs returns all supported IDEs
func GetAllIDEs() []IDE {
	return []IDE{IDECline, IDECursor, IDEVSCode, IDEClaude}
}

// GetCLISource returns the CLI source identifier
func GetCLISource() string {
	if source := getEnv("CEREBRAS_MCP_IDE"); source != "" {
		return source
	}
	return "cli"
}

// EnsureDir creates a directory if it doesn't exist
func EnsureDir(path string) error {
	if path == "" {
		return nil
	}
	return os.MkdirAll(path, 0755)
}

// FileExists checks if a file exists
func FileExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && !info.IsDir()
}

// WriteFile creates or overwrites a file with the given content
func WriteFile(path, content string) error {
	// Ensure the directory exists
	if err := EnsureDir(filepath.Dir(path)); err != nil {
		return err
	}

	return os.WriteFile(path, []byte(content), 0644)
}

// ReadFile reads the content of a file
func ReadFile(path string) (string, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(content), nil
}

// RemoveFile removes a file if it exists
func RemoveFile(path string) error {
	if FileExists(path) {
		return os.Remove(path)
	}
	return nil
}

// RemoveDir removes a directory and all its contents
func RemoveDir(path string) error {
	if DirExists(path) {
		return os.RemoveAll(path)
	}
	return nil
}

// DirExists checks if a directory exists
func DirExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && info.IsDir()
}
